<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: box-samples/box.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: box-samples/box.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Enum состояний бокса
 * @typedef {Object} Movement
 * @property {number} toClose бокс закрыт.
 * @property {number} toOpen бокс открыт.
 */

/**
 * Состояние бокса (открыт/закрыт)
 * @type {Movement}
 */
const Movement = {
    toClose: 0,
    toOpen: 1,
};

/**
 * Enum состояний работы бокса
 * @typedef {Object} TypeBox
 * @property {number} bottom работа как нижний бокс.
 * @property {number} top работа как верхний бокс.
 * @property {number} right работа как правый бокс.
 * @property {number} left работа как левы бокс.
 */

/**
 * Тип бокса
 * @type {{bottom: number, top: number, right: number, left: number}}
 */
const TypeBox = {
    bottom: 0,
    top: 1,
    right: 2,
    left: 3,
};
/**
 *
 * @type {Function}
 */
var Box = cc.Class({
    extends: cc.Component,

    properties: {
        _startPos: null,//Стартовая позиция бокса
        _endPos: null,//конечная позиция бокса
        _type: null,//состояние типа бокса в котором он работает
        _direction: 1,//0- закрыться 1- открыться
        _flagBlock: false,//флаг блокировки
        _amountPix: null,//путь для бокса

        timeBring: 0.2,//Время довода в секундах
        content: cc.Node,//контент над которым необходимо произвести работу
        opacityBox: 30,//Прозрачность бокса 
        indentLeft: 50,//Отступ слева (в px)
        indentRight: 50,//Отступ справа (в px)
    },

    /**
     * Осуществляет первоначальную настройку
     */
    onLoad() {
        this._init();
        this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart.bind(this));
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._getPermissionMove.bind(this));
        this.node.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd.bind(this));
    },

    /**
     * Инициализация переменных
     * @private
     */
    _init(){
        //Дальнейшее действие бокса
        this._direction = Movement.toOpen;
        this._settings();
    },

    /**
     * Действия на страт тача
     * @param {cc.Event} event
     */
    onTouchStart(event) {

    },

    /**
     * Действия на движение тача
     * @param {cc.Event} event
     */
    onTouchMove(event) {
        var delta = event.touch.getDelta();
        if (!this._flagBlock) {
            this._setMovement(delta)._moveBox(delta);
        }
    },

    /**
     * Действие на завершение тача
     * @param {cc.Event} event
     */
    onTouchEnd(event) {
        if (!this._flagBlock) {
            this._endSwipe();
        }
    },

    /**
     * Включить блокировку бокса
     */
    onBlock(){
        this._flagBlock = true;
    },

    /**
     * Выключить блокировку бокса
     */
    offBlock(){
        this._flagBlock = false;
    },

    /**
     * Открывает бокс
     */
    openBox(){
        this._direction = Movement.toOpen;
        this._endSwipe();
    },

    /**
     * Закрывает бокс
     */
    closeBox(){
        this._direction = Movement.toClose;
        this._endSwipe();
    },

    /**
     * Определяет ожидаемое состояние по направлению движения бокса
     * @param delta
     * @returns {Box}
     * @private
     */
    _setMovement(delta) {
        if (this._type === TypeBox.top) {
            this._direction = delta.y > 0 ? Movement.toClose : Movement.toOpen;
        } else if (this._type === TypeBox.bottom) {
            this._direction = delta.y &lt; 0 ? Movement.toClose : Movement.toOpen;
        } else if (this._type === TypeBox.left) {
            this._direction = delta.x &lt; 0 ? Movement.toClose : Movement.toOpen;
        } else {
            this._direction = delta.x > 0 ? Movement.toClose : Movement.toOpen;
        }
        return this;
    },

    /**
     * Проверка на выход бокса за пределы интервала в резудьтате выполнения данного приращения. true-когда он не выходит
     * @param delta приращение координаты
     * @param start стартовая координа(координата закрытого бокса)
     * @param end конечная координата(координата открытого бокса)
     * @param current текущаа координата
     * @return {boolean} true- если бокс не выходит за пределы
     * @private
     */
    _isCheckOutOfRange(delta, start, end, current){
        return start &lt; end ? this._isOutOfRangeLeftBottom(delta, start, end, current) : this._isOutOfRangeRightTop(delta, start, end, current);
    },

    /**
     * Проверка на выход левого и нижнего бокса за пределы интервала в резудьтате выполнения данного приращения
     * @param delta
     * @param start
     * @param end
     * @param current
     * @returns {boolean}
     * @private
     */
    _isOutOfRangeLeftBottom(delta, start, end, current){
        return delta + current > start &amp;&amp; delta + current &lt; end;
    },

    /**
     * Проверка на выход верхнего и правого бокса за пределы интервала в резудьтате выполнения данного приращения
     * @param delta
     * @param start
     * @param end
     * @param current
     * @returns {boolean}
     * @private
     */
    _isOutOfRangeRightTop(delta, start, end, current){
        return delta + current &lt; start &amp;&amp; delta + current > end;
    },

    /**
     * Движение бокса
     * @param {cc.Vec2} delta
     * @returns {Box}
     * @private
     */
    _moveBox(delta) {
        if (this._type === TypeBox.top || this._type === TypeBox.bottom) {
            (this._isCheckOutOfRange(delta.y, this._startPos.y, this._endPos.y, this.node.y)) ? this.node.y += delta.y : this._endSwipe();
        } else {
            (this._isCheckOutOfRange(delta.x, this._startPos.x, this._endPos.x, this.node.x)) ? this.node.x += delta.x : this._endSwipe();
        }
        return this;
    },

    /**
     * Выполняет авто доводку
     * @private
     */
    _endSwipe(){
        this._flagBlock = true;
        this._direction === Movement.toClose ? this._bring(this._startPos) : this._bring(this._endPos);
        this._refocus();
    },

    /**
     * Выполняет авто довод  бокса до финальной точки назначения
     * @param pos точка назначения
     * @private
     */
    _bring(pos){
        var action = cc.moveTo(this.timeBring, pos);
        this.node.runAction(
            cc.sequence(action, cc.callFunc(this._finishBring, this))
        );
    },

    /**
     * Функция сигнализирующая о завершении доводки бокса
     * @private
     */
    _finishBring(){
        this._flagBlock = false;
    },

    /**
     * Проверяет делает ли он это событие а не кто-то другой по ветке нодов до него
     * @param event
     * @private
     */
    _getPermissionMove(event) {
        if (event.target._name === this.node.name) {
            this.onTouchMove(event);
        }
    },

    /**
     * Возвращает размер бокса относительно пространства на стороне и условий отступов
     * @param {number} space
     * @returns {number} размер бокса
     * @private
     */
    _getSizeBox(space) {
        return space - this.indentLeft - this.indentRight;
    },

    /**
     * Меняет действие которое необходимо сделать дальше боксу(закрыться или открыться).Публикует событие
     * @private
     */
    _refocus() {
        if (this._direction === Movement.toClose) {
            this._direction = Movement.toOpen;
            this.publishEventClose();
        } else {
            this._direction = Movement.toClose;
            this.publishEventOpen();
        }
    },

    /**
     * Работа с прозрачностью бокса. Изменяет прозрачность бокса на основе положения его относительно начальных и конечных координат
     * @private
     */
    _opacityNode(currentPosBox) {
        let opasity = this.opacityBox + (((255 - this.opacityBox) * currentPosBox) / this._amountPix);
        if (opasity > 255) {
            opasity = 255;
        } else if (opasity &lt; this.opacityBox) {
            opasity = this.opacityBox;
        }
        this.node.opacity = opasity;
    },
});

export { Box, Movement, TypeBox };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#_settings">_settings</a></li><li><a href="global.html#Box">Box</a></li><li><a href="global.html#BoxCharacteristicsAnimal">BoxCharacteristicsAnimal</a></li><li><a href="global.html#BoxCreateAnimal">BoxCreateAnimal</a></li><li><a href="global.html#closeBox">closeBox</a></li><li><a href="global.html#offBlock">offBlock</a></li><li><a href="global.html#onBlock">onBlock</a></li><li><a href="global.html#onLoad">onLoad</a></li><li><a href="global.html#onTouchEnd">onTouchEnd</a></li><li><a href="global.html#onTouchMove">onTouchMove</a></li><li><a href="global.html#onTouchStart">onTouchStart</a></li><li><a href="global.html#openBox">openBox</a></li><li><a href="global.html#publishEventClose">publishEventClose</a></li><li><a href="global.html#publishEventOpen">publishEventOpen</a></li><li><a href="global.html#TypeBox">TypeBox</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Mar 28 2017 10:09:50 GMT+0700 (Алтайское стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
