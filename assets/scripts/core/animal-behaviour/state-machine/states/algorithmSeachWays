
export default class Animal{
    constructor(targetPos,currentPos,speed,node,map){
        this.node=node;
        this.speed=speed;
        this.targetPos=targetPos;
        this.currentPos=currentPos;
        this.map=map;

    }
    /**
     * алгоритм нахождения пути
     * по идеи на вход подаются текущая точка и точка для достижения цели
     * Необходимые значения
     */
    A(){
        var tileStart=this.map.getTilePos(this.currentPos);//сторонний метод   
        var tileEnd=this.map.getTilePos(this.targetPos); //сторонний метод          
        //tileEnd=cc.p(13,14);
        //console.log(tileEnd);
        //console.log(tileStart);
        var closed=[];//посетили
        var open=[];//еще непосетиили
        open.push(tileStart);//начинаем со старта
        var puth=[];//карта которая восстанавливает в дальнейшем наш путь
        var arr=[];       
        while(open.length>0){    
            let curr=this.minF(open,tileEnd);
            if(curr.x===tileEnd.x&&curr.y===tileEnd.y) {                
                return this.foundPuth(puth,tileEnd);
            }         
            closed.push(curr);
            this.removeElement(curr,open);
            arr= [];
            this.getElementNotInClosedForCurr(closed,curr).forEach((element)=>{
                if(this.checkInMass(open,element)){
                    arr.push(curr);
                    arr.push(element);
                    open.push(element);
                }
            });
            puth.push(arr);
        }
        return false;
    }

    /**
     * конструирует путь до цели
     */
    foundPuth(puth,end){
        let arr=[];
        for(let i=puth.length-1;i>=0;i--){
          var row = puth[i]; 
            for(let j=1, length = row.length;j<length;j+=2){
                if(end.x===row[j].x&&end.y===row[j].y){
                    arr.push(end);
                    end=row[j-1];
                    break;
                }
            }
        }
        return arr;
    }

    /**
     * Сглаживает путь
     * 
     */
    correctPuth(puth){
        if(puth){
            let target=1;
            var element1,
                element2,
                element3;
            while(target!=0){
                target=0;
                for(let i=0;i<puth.length-3;i++){
                    element1=puth[i],
                    element2=puth[i+1],
                    element3=puth[i+2];
                    if(Math.abs(element1.x-element3.x)===1&&Math.abs(element1.y-element3.y)===1){
                        if(element2.x===element1.x){
                            target=cc.v2(element3.x,element1.y);
                        }else{
                            target=cc.v2(element1.x,element3.y);
                        }
                        if(this.map.chek(target)){//сторонний метод
                            //надо удалить вершину puth[i+1];
                            puth.splice(i+1,1);
                        }else{
                            //сигнализируем об отсутствии вершины
                            target=0;
                        }             
                    }
                }
            }
        }
        return puth;
    }
   
    /**
     * Возвращает матрицу соседей удовлетворяющих условиям и не числющихся в просмотренных
     */
    getElementNotInClosedForCurr(closed,curr){
        let arr=[];
        let p;
        p=cc.p(curr.x,curr.y+1);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){   //сторонний 1 метод        
            arr.push(p);
        }
        p=cc.p(curr.x,curr.y-1);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){//сторонний 1 метод   
            arr.push(p);
        }
       
        p=cc.p(curr.x+1,curr.y);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){//сторонний 1 метод   
            arr.push(p);
        }
        p=cc.p(curr.x-1,curr.y);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){//сторонний 1 метод   
            arr.push(p);
        }
    
       /*  p=cc.p(curr.x-1,curr.y+1);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){
            arr.push(p);
        }
        p=cc.p(curr.x-1,curr.y-1);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){
            arr.push(p);
        }
        p=cc.p(curr.x+1,curr.y+1);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){
            arr.push(p);
        }
        p=cc.p(curr.x+1,curr.y-1);
        if(this.map.chek(p)&&this.checkInMass(closed,p)){
            arr.push(p);
        }
        */
       
    
    return arr;
    
    }
    /**
     * Проверяет находится ли элемент в массиве просмотренных или нет
     * @param {Array<any>} closed
     */
    checkInMass(closed,element){
        return closed.find((item) => item.x===element.x && item.y===element.y)? false : true;
    }
    /**
     * Удалаяет указанный элемент из массива
     * @param {Array<any>} mass
     */
    removeElement(element,mass){
        var index = mass.findIndex((item) => element.x===item.x && element.y===item.y);    
        mass.splice(index,1);
        //return index? mass.splice(index,1) : false;      
    }
    /**
     * Ищет такой элементкоторый самый близкий к финальной точке 
     * @param {Array<any>} mas
     */
    minF(mas,tileEnd){
        let min = Number.MAX_VALUE;
        let minItem=null;
        mas.forEach((item,i)=>{
            var vremen=this.h(item,tileEnd);
            if(vremen<min){
                min=vremen;
                minItem = item;
            }
          
        });
        return  minItem;
    }

    /**
     * Эвристическая функция проврки расстояния до назанчения
     */
    h(start,end){
      
        return Math.sqrt((end.x-start.x)**2+(end.y-start.y)**2);
    }


    //-Создание новой конечной точки пропитано быдло кодом
    _newPos(){
            this.targetPos=_getRandomCoordinat(this.map.sizeMap.width,this.map.sizeMap.height);
            this.targetPos=cc.v2(this.targetPos.x+this.map.worldTileSize.width/2,this.targetPos.y+this.map.worldTileSize.height/2);
            
    }
    //проверяем полученную точку на ряд условий
    createEndPos(){
        let param;     
        do{
        this._newPos();      
        param=this.map.getTilePos(this.targetPos);
        if(param.x>0&&param.y>0&&param.x<this.map.worldTileSize.width&&param.y<this.map.worldTileSize.height){
            param=this.map.getAmountBarriier(param);
            if(param===0){
                break;
            }        
        }
       
        }while(true);
    }

    //Движение по заданному маршруту
    run(targ){
     
        //создание новой цели для движения
        this.node.x=this.currentPos.x;
        this.node.y=this.currentPos.y;
        this.createEndPos();
        targ.setPosition( this.targetPos.x, this.targetPos.y);

        let list;        
        list= this.correctPuth(this.A());//наложили фильтр сглаживания на путь до цели
        if(!list){
            return;
        }       
        let endPos,pos;   
        var actions =[]; 
        let time=0.4;
        while(list.length>0){
            pos=list.pop();               
            endPos=this.map.getMapPos(pos);            
            actions.push(cc.moveTo(time , endPos));
        
        }    
       
        this.node.runAction(
            cc.sequence(...actions)
        );   
            
    }
    
}



  function  _getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min)) + min;
    }

 function  _getRandomCoordinat(maxPosx,maxPosy){
      return cc.v2(_getRandomInt(0,maxPosx),_getRandomInt(0,maxPosy));
    }
